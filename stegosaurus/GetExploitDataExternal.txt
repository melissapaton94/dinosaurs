import pandas as pd
import requests
import json
import urllib
import getpass
import os
import sys
import msvcrt
from io import StringIO
import io
import pickle

def GetPassword(prompt):
    #Replacement for getpass.getpass() which doesn't show password chars being echoed. Uncomment the print lines for a version which prints asterisks for each character typed
    print(prompt, end='', flush=True)
    buf = ''
    while True:
        ch = msvcrt.getch()
        if ch.decode('utf-8') == '\r':
            #print('')
            break
        else:
            buf += ch.decode('utf-8')
            #print('*', end='', flush=True)
    return buf

# this is constant, so set it up here
headers = {'user-agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'}

# This obtains the MITRE list of ExploitDB entries mapped to CVEs. Note that this is a subset of the whole ExploitDB database.
url = 'https://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html'
r = requests.get(url, headers=headers)
edb_mitre = pd.read_html(r.content)
edb_mitre = edb_mitre[3] # it's the fourth table on the page

# this obtains the whole ExploitDB summary database with ExploitDB-Ids mapping to the exploit type (i.e. DoS, local, remote, WebApp)
url = 'https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv'
r = requests.get(url, headers=headers)
edb_summary = pd.read_csv(StringIO(r.content.decode('utf-8')))
edb_summary.set_index("id", inplace=True)

# Iterate through the table checking the ExploitDB page for each retrieved exploit
remoteSploits = list()
localAndDoSSploits = list()
noEDBRecord = list()

# Store the ExploitDB numbers by severity of associated exploit. TODO convert to use CVE numbers
for exploit in edb_mitre.values:
    # split EDB reference by colon
    sploitNumber  = exploit[0].split(':')[1]
    try:
        edb_instance = edb_summary.loc[int(sploitNumber)]
    except KeyError:
        noEDBRecord.append(sploitNumber)
        continue
    except: # non-key error exceptions, just skip for now, there is a single row that has 'Exploit Database' as its number, so thats getting ignored for now.
        continue

    # We have a match, so get the CVE numbers
    CVERefs = exploit[1].split(' ')
    # check if response indicates this exploit is either for a remote exploit or for a web app exploit
    if edb_instance['type'] == 'remote' or edb_instance['type'] == 'webapps':
        for CVE in CVERefs:
            if CVE not in remoteSploits:
                remoteSploits.append(CVE)
    else:
        for CVE in CVERefs:
            if CVE not in localAndDoSSploits:
                localAndDoSSploits.append(CVE)

# We now have three lists of CVEs, one with web/RCE exploits, one with local/DoS exploits (less serious) and one with no ability to match. 
# Need to decide what to output from here (json?)

if os.path.isfile("./remoteSploits.json"):
    # Got existing older files, so useful Diffs can be done here. Otherwise, the previous files didn't exist, likely because this is a first run.
    with open ("./remoteSploits.json", "r") as readfile:
        remoteSploitsOld = json.load(readfile)

    with open ("./localAndDoSSploits.json", "r") as readfile:
        localAndDoSSploitsOld = json.load(readfile)

    #check for new findings. Doesn't care about stuff that has disappeared from teh new list, only stuff that is new on there but missing from the old list.
    newRemoteSploits = list(set(remoteSploits) - set(remoteSploitsOld))
    newLocalAndDoSSploits = list(set(localAndDoSSploits) - set(localAndDoSSploitsOld))


# Write useful files out so they can be diffed another time.
with open("./remoteSploits.json", "w") as writefile:
    json.dump(remoteSploits, writefile)

with open("./localAndDoSSploits.json", "w") as writefile:
    json.dump(localAndDoSSploits, writefile)


